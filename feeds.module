<?php
// $Id: feeds.module,v 1.7 2009/09/21 14:55:47 alexb Exp $
/**
 * @file
 * Feeds - basic API functions and hook implementations.
 */

// Vague request time. Use as common point of reference and to avoid costly
// calls to time().
define('FEEDS_REQUEST_TIME', time());
// Do not schedule a feed for refresh.
define('FEEDS_SCHEDULE_NEVER_REFRESH', -1);
// A feed object is not persistent at all. Compare to EXPORT_IN_DATABASE OR
// EXPORT_IN_CODE.
define('FEEDS_EXPORT_NONE', 0);

/**
 * Implementation of hook_cron().
 */
function feeds_cron() {
  feeds_include('scheduler');
  feeds_scheduler_cron();
}

/**
 * Implementation of hook_cron_queue_info().
 * Invoked by drupal_queue module if present.
 */
function feeds_cron_queue_info() {
  $queues = array();
  $queues['feeds_queue'] = array(
    'worker callback' => 'feeds_scheduler_refresh',
    'time' => variable_get('feeds_worker_time', 60),
  );
  return $queues;
}

/**
 * Implementation of hook_perm().
 *
 * @todo: add more fine grained permissions for every single configuration.
 */
function feeds_perm() {
  return array('use feeds', 'administer feeds');
}

/**
 * Implementation of hook_forms().
 *
 * @todo: move down below hook implementations and callbacks.
 */
function feeds_forms() {
  // Declare form callbacks for all known classes derived from FeedsConfigurable.
  $forms = array();
  $forms['Feed_feeds_config_form']['callback'] = 'feeds_config_form';
  $plugins = feeds_get_plugins();
  foreach ($plugins as $plugin) {
    // See feeds_get_config_form().
    $forms[$plugin['handler']['class'] .'_feeds_config_form']['callback'] = 'feeds_config_form';
  }
  return $forms;
}

/**
 * Implementation of hook_menu().
 */
function feeds_menu() {
  // Register a callback for all feed configurations that are not attached to a content type.
  $items = array();
  foreach (feeds_load_all() as $feed) {
    if (empty($feed->config['content_type'])) {
      $items['import/'. $feed->id] = array(
        'title' => $feed->config['name'],
        'page callback' => 'drupal_get_form',
        'page arguments' => array('feeds_import_form', 1),
        'access arguments' => array('use feeds'),
        'file' => 'feeds.pages.inc',
      );
      $items['import/'. $feed->id .'/import'] = array(
        'title' => 'Import',
        'type' => MENU_DEFAULT_LOCAL_TASK,
        'weight' => -10,
      );
      $items['import/'. $feed->id .'/delete-items'] = array(
        'title' => 'Delete items',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('feeds_delete_items_form', 1),
        'type' => MENU_LOCAL_TASK,
        'access arguments' => array('use feeds'),
        'file' => 'feeds.pages.inc',
      );
    }
    else {
      $items['node/%node/import'] = array(
        'title' => 'Import',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('feeds_import_node_form', 1),
        'access arguments' => array('use feeds'),
        'file' => 'feeds.pages.inc',
        'type' => MENU_LOCAL_TASK,
        'weight' => 10,
      );
      $items['node/%node/delete-items'] = array(
        'title' => 'Delete items',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('feeds_delete_items_form', NULL, 1),
        'type' => MENU_LOCAL_TASK,
        'access arguments' => array('use feeds'),
        'file' => 'feeds.pages.inc',
        'weight' => 11,
      );
    }
  }

  if (count($items)) {
    $items['import'] = array(
      'title' => 'Import content',
      'page callback' => 'feeds_page',
      'access arguments' => array('use feeds'),
      'file' => 'feeds.pages.inc',
    );
  }
  return $items;
}

/**
 * Menu loader callback.
 */
function feeds_load($id) {
  return feeds_feed_instance($id);
}

/**
 * Implementation of hook_theme().
 */
function feeds_theme() {
  return array(
    'feeds_info' => array(
      'file' => 'feeds.pages.inc',
    ),
  );
}

/**
 * Implementation of hook_ctools_plugin_api().
 */
function feeds_ctools_plugin_api($owner, $api) {
  if ($owner == 'feeds' && $api == 'plugins') {
    return array('version' => 1);
  }
}

/**
 * Implementation of hook_feeds_plugins().
 *
 * @todo: Document API. Uses CTools plugin handling, extra keys:
 * 'description', 'hidden'
 *
 * @todo: Also declare and load Feed and FeedsConfigurable class with this API?
 */
function feeds_feeds_plugins() {
  module_load_include('inc', 'feeds', 'feeds.plugins');
  return _feeds_feeds_plugins();
}

/**
 * Implementation of hook_nodeapi().
 */
function feeds_nodeapi($node, $op) {

  // Break out node processor related nodeapi functionality in its own function.
  _feeds_nodeapi_node_processor($node, $op);

  switch ($op) {
    case 'insert':
    case 'update':
      if ($feed = feeds_get_by_content_type($node->type)) {
        // Node module magically moved $form['feeds'] to $node->feeds.
        // Save feed source and refresh feed.
        $source = feeds_source_instance($feed, $node->nid);
        $source->setConfig($node->feeds);
        $source->save();
        $feed->import($source);

        // Add feed to scheduler.
        feeds_include('scheduler');
        feeds_scheduler_add($feed, $node->nid);
      }
      break;
    case 'view':
      if ($feed = feeds_get_by_content_type($node->type)) {
        module_load_include('inc', 'feeds', 'feeds.pages');
        // @todo: remove or expand on this approach.
        $node->content['feeds_info']['#value'] = feeds_control_box($feed);
        $node->content['feeds_info']['#weight'] = -10;
      }
      break;
    case 'delete':
      if ($feed = feeds_get_by_content_type($node->type)) {
        feeds_include('scheduler');
        // Remove feed from scheduler and delete source.
        feeds_scheduler_remove($feed, $node->nid);
        $feed->fetcher->deleteSource($node->nid);
      }
      break;
  }
}

/**
 * Break out FeedsNodeProcessor specific nodeapi operations.
 */
function _feeds_nodeapi_node_processor($node, $op) {
  switch ($op) {
    case 'load':
      if ($result = db_fetch_object(db_query('SELECT imported, guid, url FROM {feeds_node_item} WHERE nid = %d', $node->nid))) {
        $node->feeds_node_item = $result;
      }
      break;
    case 'insert':
      if (isset($node->feeds_node_item)) {
        $node->feeds_node_item->nid = $node->nid;
        drupal_write_record('feeds_node_item', $node->feeds_node_item);
      }
      break;
    case 'update':
      if (isset($node->feeds_node_item)) {
        $node->feeds_node_item->nid = $node->nid;
        drupal_write_record('feeds_node_item', $node->feeds_node_item, 'nid');
      }
      break;
    case 'delete':
      if (isset($node->feeds_node_item)) {
        db_query('DELETE FROM {feeds_node_item} WHERE nid = %d', $node->nid);
      }
      break;
  }
}

/**
 * Implementation of hook_form_alter().
 */
function feeds_form_alter(&$form, $form_state, $form_id) {
  if ($form['#id'] == 'node-form') {
    if ($feed = feeds_get_by_content_type($form['type']['#value'])) {
      $form['feeds'] = array(
        '#type' => 'fieldset',
        '#title' => t('Feed'),
        '#tree' => TRUE,
      );
      $form['feeds'] += $feed->fetcher->sourceForm($form['nid']['#value']);

      // For some reason I cannot pass on the feed object, pass on id.
      $form['#feed_id'] = $feed->id;
      // Only set validation handler. Save object on 'insert'
      $form['#validate'][] = 'feeds_import_form_validate';
    }
  }
}

/**
 * Validation handler for node forms and feeds_import_form().
 *
 * Has to live in feeds.module, needs to be callable from node form.
 *
 * @todo: find a way to move to feeds.pages.inc.
 */
function feeds_import_form_validate($form, &$form_state) {
  $feed = feeds_feed_instance($form['#feed_id']);
  $source = feeds_source_instance($feed);
  // @todo: this may be a problem here, as we don't have a feed_nid at this point.
  $source->configFormValidate($form, $form_state['values']['feeds']);
}

/**
 * Submit handler for feeds_import_form().
 *
 * Cannot be used for node form, as node form executes all submit handlers in
 * node_form_submit_build_node() /before/ it creates the node and a node nid
 * is known :(
 *
 * @todo: move to feeds.pages.inc.
 */
function feeds_import_form_submit($form, &$form_state) {
  $feed = feeds_feed_instance($form['#feed_id']);
  $source = feeds_source_instance($feed);

  // Save source and import.
  $source->configFormSubmit($form, $form_state['values']['feeds']);
  $source->save();
  $feed->import($source);

  // Add feed to scheduler.
  feeds_include('scheduler');
  feeds_scheduler_add($feed);
}

/**
 * Refreshes a feed identified by $feed_info.
 *
 * Used as a worker callback for drupal_queue.
 *
 * @param $feed_info
 *   Array where the key 'id' is the id of a Feed object and the key 'feed_nid'
 *   is the node id of feed node.
 */
function feeds_scheduler_refresh($feed_info) {
  feeds_include('scheduler');
  _feeds_scheduler_refresh($feed_info);
}

/**
 * Get all available plugins. Does not list hidden plugins.
 *
 * @return
 *   An array where the keys are the plugin keys and the values
 *   are the plugin info arrays as defined in hook_feeds_plugins().
 */
function feeds_get_plugins() {
  ctools_include('plugins');
  $plugins = ctools_get_plugins('feeds', 'plugins');

  $result = array();
  foreach ($plugins as $key => $info) {
    if ($info['hidden'] == TRUE) {
      continue;
    }
    $result[$key] = $info;
  }
  return $result;
}

/**
 * Get all available plugins categorized by whether they are a
 * fetcher, a parser or a processor plugin.
 *
 * Does not list hidden plugins.
 *
 * @return
 *   An array where the keys are plugin types and the elements are
 *   arrays of plugin info arrays.
 *
 *   Example:
 *   array(
 *     'fetcher' => array(
 *       'FeedsFileFetcher' => array(
 *          // File fetcher info.
 *       ),
 *       'FeedsHttpFetcher' => array(
 *          // Http fetcher info.
 *     ),
 *     'parser' => array(
 *       // All available processors, following the pattern of the fetcher array.
 *     ),
 *     'processor => array(
 *       // All available parsers, following the pattern of the fetcher array.
 *     ),
 *   );
 */
function feeds_get_plugins_by_type() {
  $plugins = feeds_get_plugins();

  $result = array();
  foreach ($plugins as $key => $info) {
    if ($plugin_type = feeds_plugin_type($key)) {
      $result[$plugin_type][$key] = $info;
    }
  }
  return $result;
}

/**
 * Load a plugin's class file.
 *
 * @param $plugin
 *   The key of the plugin.
 *
 * @return
 *   String that identifies the class name associated with this plugin.
 *   The class name is the one specified in the plugins $info['handler'] property.
 */
function feeds_load_plugin_class($plugin) {
  ctools_include('plugins');
  return ctools_plugin_load_class('feeds', 'plugins', $plugin, 'handler');
}

/**
 * Load all feeds.
 */
function feeds_load_all() {
  ctools_include('export');
  $configs = ctools_export_load_object('feeds_config', 'conditions', array('class' => 'Feed'));
  $feeds = array();
  foreach ($configs as $config) {
    if ($config->id) {
      $feeds[$config->id] = feeds_feed_instance($config->id);
    }
  }
  return $feeds;
}

/**
 * Utility function: import a feed. Expects a stored source.
 *
 * Use this when source at the time of call is not present.
 *
 * @param $feed
 *   Feed object.
 * @param $feed_nid
 *   The id of the node the source is attached to. Can be 0 if
 *   the source is not attached to a node at all - e. g. if it
 *   has been defined on a standalone import form.
 *
 * @throws FeedsNoSourceException
 *   If source cannot be loaded with given information.
 */
function feeds_import($feed, $feed_nid = 0) {
  $source = feeds_source_instance($feed, $feed_nid);
  if ($source->export_status == FEEDS_EXPORT_NONE) {
    throw new FeedsNoSourceException('Expected source information in database for '. $feed->id .'/'. $feed_nid .'. Could not find any.');
  }
  $feed->import($source);
}

/**
 * Get an instance of Feed object.
 *
 * @param $id
 *   A string that is the id of the object.
 */
function feeds_feed_instance($id) {
  feeds_include('feed');
  return FeedsConfigurable::instance(variable_get('feed_class', 'Feed'), $id);
}

/**
 * Get an instance of a source object.
 *
 * @param $feed
 *   A Feed object.
 * @param $feed_nid
 *   The node id of a feed node if the source is attached to a feed node.
 */
function feeds_source_instance($feed, $feed_nid = 0) {
  feeds_include('feed');
  return FeedsSource::instance(variable_get('source_class', 'FeedsSource'), $feed, $feed_nid);
}

/**
 * Get an instance of a class for a given plugin and id.
 *
 * @param $plugin
 *   A string that is the key of the plugin to load.
 * @param $id
 *   A string that is the id of the object.
 */
function feeds_plugin_instance($plugin, $id) {
  feeds_include('feed');
  if ($class = feeds_load_plugin_class($plugin)) {
    return FeedsConfigurable::instance($class, $id);
  }
  return NULL;
}

/**
 * Get a feed configuration by content type.
 *
 * @todo: speed this up by caching the result.
 *
 * @param $content_type
 *   A node type string.
 *
 * @return
 *   A Feed object if one is available, FALSE otherwise.
 */
function feeds_get_by_content_type($content_type) {
  static $feeds = array();

  if (!isset($feeds[$content_type])) {
    $feeds[$content_type] = FALSE;
    foreach (feeds_load_all() as $feed) {
      if ($feed->config['content_type'] == $content_type) {
        $feeds[$content_type] = $feed;
        break;
      }
    }
  }
  return $feeds[$content_type];
}

/**
 * Includes a feeds module include file.
 *
 * @param $file
 *   The filename without the .inc extension.
 * @param $directory
 *   The feeds subdirectory the file resides in.
 */
function feeds_include($file, $directory = 'includes') {
  static $included = array();
  if (!isset($included[$file])) {
    require_once './' . drupal_get_path('module', 'feeds') . "/$directory/$file.inc";
  }

  $included[$file] = TRUE;
}

/**
 * Determines whether given plugin is derived from given base plugin.
 *
 * @todo: update variable names. Should be $plugin_key if it is a key string.
 *
 * @param $plugin
 *   String that identifies a Feeds plugin key.
 * @param $parent_plugin
 *   String that identifies a Feeds plugin key to be tested against.
 *
 * @return
 *   TRUE if $parent_plugin is directly *or indirectly* a parent of $plugin,
 *   FALSE otherwise.
 */
function feeds_plugin_child($plugin, $parent_plugin) {
  ctools_include('plugins');
  $plugins = ctools_get_plugins('feeds', 'plugins');
  $info = $plugins[$plugin];

  if (empty($info['handler']['parent'])) {
    return FALSE;
  }
  elseif ($info['handler']['parent'] == $parent_plugin) {
    return TRUE;
  }
  else {
    return feeds_plugin_child($info['handler']['parent'], $parent_plugin);
  }
}

/**
 * Determine the type of a plugin.
 *
 * @param $plugin_key
 *   String that is a Feeds plugin key.
 *
 * @return
 *   One of the following values:
 *   'fetcher' if the plugin is a fetcher
 *   'parser' if the plugin is a parser
 *   'processor' if the plugin is a processor
 *   FALSE otherwise.
 */
function feeds_plugin_type($plugin_key) {
  if (feeds_plugin_child($plugin_key, 'FeedsFetcher')) {
    return 'fetcher';
  }
  elseif (feeds_plugin_child($plugin_key, 'FeedsParser')) {
    return 'parser';
  }
  elseif (feeds_plugin_child($plugin_key, 'FeedsProcessor')) {
    return 'processor';
  }
  return FALSE;
}

/**
 * Export a feed configuration.
 *
 * It actually seems that export.inc does not support multi-field keys.
 */
function feeds_export($feed_id, $indent = '') {
  ctools_include('export');
  $result = ctools_export_load_object('feeds_config', 'names', array('id' => $feed_id));
  if (isset($result[$feed_id])) {
    return ctools_export_object('feeds_config', $result[$feed_id], $indent);
  }
}
